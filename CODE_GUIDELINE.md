# CODE GUIDELINE
基本的なコーディング規則は、[「UnityでのC#スクリプティングのための命名とコードスタイルのヒント」](https://unity.com/ja/how-to/naming-and-code-style-tips-c-scripting-unity)に従います。

# フィールドと変数の表
## フィールドと変数
変数とフィールドについては、以下のルールを考慮してください：
- 変数名には名詞を使う：変数名は、特定の物事や状態を表すので、明確で説明的でなければならない。変数がbool型（下記参照）である場合を除き、命名には名詞を使用する。
- ブール語の前に動詞を付ける：これらの変数は真か偽の値を示す。というような質問に対する答えであることが多い：選手は走っているか？試合は終わったのか？
- 動詞を前につけて、意味をより明確にする。多くの場合、これは説明や条件（isDead、isWalking、hasDamageMultiplierなど）と対になっている。
- 意味のある名前を使う。略さないこと（数学でない限り）：変数名はその意図を明らかにする。発音しやすく、検索しやすい名前を選ぶ。
- ループや計算式では1文字の変数でも問題ありませんが、それ以外の状況では省略しないでください。いくつかの母音を省略することで節約できる時間よりも、明瞭さの方が重要なのだ。
- 素早くプロトタイプを作るには、一時的に短い「ジャンク」な名前を使い、後でもっと意味のある名前にリファクタリングすればいい。
- パブリック・フィールドにはパスカル・ケースを使い、プライベート変数にはキャメル・ケースを使う：パブリック・フィールドに代わるものとして、パブリックな "ゲッター "を持つプロパティを使用します（前節と後節を参照）。
- 接頭辞が多すぎたり、特殊なエンコーディングは避ける：ローカル変数と区別するために、プライベート・メンバー変数の前にアンダースコア (_) を付けることができます。
- あるいは、メンバ変数とローカル変数を文脈で区別するために this キーワードを使い、接頭辞を省略することもできます。パブリック・フィールドとプロパティは通常接頭辞を持ちません。
- スタイル・ガイドによっては、プライベートなメンバ変数（m_）、定数（k_）、静的変数（s_）に接頭辞を使用することで、変数名が一目でその変数に関する詳細がわかるようにしています。
- 多くの開発者はこれらを避け、代わりにエディターに頼っている。しかし、すべてのIDEがハイライトや色分けをサポートしているわけではなく、リッチコンテキストをまったく表示できないツールもある。チームとしてどのように接頭辞を適用するか（あるいは適用するかどうか）を決定する際には、この点を考慮してください。
- アクセスレベル修飾子を一貫して指定する（または省略する）：アクセス修飾子を省略すると、コンパイラーはアクセス・レベルをprivateとみなす。これはうまくいくが、デフォルトのアクセス修飾子を省略する方法には一貫性を持たせよう。
- 後でこれをサブクラスで使いたい場合は、protectedを使う必要があることを覚えておいてほしい。

## 列挙
列挙型は、名前付き定数の集合によって定義される特殊な値型である。デフォルトでは、定数はゼロから始まる整数である。
列挙型の名前と値にはパスカル・ケースを使用する。パブリックな列挙型をクラスの外部に置くことで、それらをグローバルにすることができる。列挙名には単数名詞を使用する。
注：でマークされたビット単位の列挙型。 属性でマークされたビット単位の列挙型は、この規則の例外である。複数のタイプを表すため、通常は複数形にする。

## クラスとインターフェース
クラスやインターフェースの名前をつけるときは、以下の標準的なルールに従ってください：
- クラス名にはパスカル・ケースの名詞を使う：そうすることで、クラスを整理することができる。
- ファイル内にMonoBehaviourがある場合、ソースファイル名が一致していなければなりません：ファイル内に他の内部クラスがあるかもしれませんが、MonoBehaviourは1ファイルにつき1つだけ存在するようにしてください。
- インターフェイス名の前に大文字の "I "を付ける： その後に、機能性を表す形容詞を続ける。

## 方法
C#では、実行される命令はすべてメソッドのコンテキスト内で実行される。
- メソッドはアクションを実行するので、これらのルールを適用して適切な名前を付ける：
- 名前を動詞で始める： 必要に応じてコンテキストを追加する（GetDirection、FindTargetなど）。
- パラメータにはキャメルケースを使用する： メソッドに渡されるパラメータをローカル変数のようにフォーマットする。
- boolを返すメソッドは質問をする： ブール変数そのものと同じように、メソッドが真偽の条件を返す場合は動詞をプレフィックスとしてつけます。IsGameOver、HasStartedTurnなど）。
注：Unityの開発では、"ファンクション "と "メソッド "という言葉はしばしば同じ意味で使われます。しかし、C#ではクラスに組み込まずに関数を書くことはできないので、「メソッド」というのが正しい呼び方である。

## イベントとイベントハンドラ
C#のイベントはオブザーバー・パターンを実装しています。このソフトウェアデザインパターンは、1つのオブジェクトであるサブジェクト（またはパブリッシャー）が、オブザーバー（またはサブスクライバー）と呼ばれる依存オブジェクトのリストに通知できる関係を定義します。このように、主体は、関係するオブジェクトを緊密に結合させることなく、オブザーバーに状態変化をブロードキャストすることができる。
被写体やオブザーバーにおけるイベントやそれに関連するメソッドには、いくつかの命名法が存在する。以下のセクションの実践を試してみてください。

- 動詞を使う
  - 動詞のフレーズでイベントの名前を付ける。状態の変化を正確に伝えるものを選ぶようにしましょう。
- 現在分詞または過去分詞を使って、出来事の前後の状態を示す。例えば、ドアを開ける前のイベントには "OpeningDoor "を、開けた後のイベントには "DoorOpened "を指定する。
- System.Actionを使用する
  - イベントにはSystem.Actionデリゲートを使用します。ほとんどの場合 Action<T>デリゲートはゲームプレイに必要なイベントを処理できる。
- 戻り値の型はvoidで、異なる型の入力パラメータを16個まで渡すことができる。定義済みのデリゲートを使えば、コードを節約できる。
注：また イベントハンドラまたは EventHandler<TEventArgs>のデリゲートを使うこともできる。全員がどのようにイベントを実施すべきか、チームとして合意する。

## メソッドの前に "On "を付ける
件名の）イベント提起方法の前に "On "を付ける。イベントを呼び出すサブジェクトは、通常、"On "の接頭辞が付いたメソッド（例えば、"OnOpeningDoor "または "OnDoorOpened"）から呼び出す。

## 被写体名とアンダースコアで接頭辞を付ける
(オブザーバー内の)イベント処理メソッドの前に、対象の名前とアンダースコア(_)を付ける。オブジェクトの名前が "GameEvents "であれば、オブザーバーは "GameEvents_OpeningDoor "または "GameEvents_DoorOpened "というメソッドを持つことができる。

## EventArgsの使用は慎重に
必要な場合のみ、カスタムEventArgsを作成する。イベントにカスタムデータを渡す必要がある場合は、EventArgsの新しいタイプを作成します。 から継承するかから継承するか、カスタム構造体から作成します。


## 名前空間
名前空間を使用して、クラス、インターフェース、列挙型などが、他の名前空間やグローバル名前空間に存在するものと衝突しないようにします。名前空間は、Unity Asset Storeのサードパーティ製アセットや、プロジェクトの最終バージョンには含まれない他のテストシーンとの競合を防ぐこともできます。

### 名前空間を適用する場合
特殊記号やアンダースコアのないパスカルケースを使用する。
名前空間接頭辞の繰り返し入力を避けるために、ファイルの先頭にusingディレクティブを追加する。
サブネームスペースも作成する。ドット(.)演算子を使用して名前のレベルを区切ることで、スクリプトを階層的なカテゴリに整理することができます。例えば、"MyApplication.GameFlow"、"MyApplication.AI"、"MyApplication.UI "などを作成し、ゲームの異なる論理コンポーネントを保持することができます。

## 接頭辞
コードでは、これらのクラスをそれぞれEnemy.Controller1、Enemy.Controller2と呼ぶ。接頭辞の入力を省くためにusing行を追加する（例：Enemy;を使う）。
コンパイラはController1とController2というクラス名を見つけると、Enemy.Controller1とEnemy.Controller2という意味だと理解する。
スクリプトが異なる名前空間から同じ名前のクラスを参照する必要がある場合は、接頭辞を使用してそれらを区別します。例えば、Player名前空間にController1クラスとController2クラスがある場合、Player.Controller 1とPlayer.Controller2と記述することで、競合を避けることができます。そうでない場合、コンパイラーはエラーを報告する。

# 追加規則
以下の追加規則は、上の規則によりも優先されます。

## コメントアウト
- コメントアウトは日本語での記述を基本とする
- コメントアウトは、コードの意図や目的を説明するために使用される。コードが何をしているのか、なぜそうするのか、どのように動作するのかを説明する。
- SerializedFieldの説明として、<summary>タグを使用することができます。これにより、Unityのエディターでフィールドの説明が表示されます。

## クラス命名規則
- ArtNetUnityにかかわるスクリプトのクラス名には先頭に`ANU`をつけます
  - これは、ArtNetUnityのスクリプトであることを明示するためです
- クラス名はパスカルケースを使用します

